<!DOCTYPE html>
<!-- Ben Athiwaratkun (c) 2014 -->
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Home Page - Ben Athiwaratkun</title>
    <script type="text/javascript" src="../d3/d3.min.js"></script>
    <style type="text/css">
        .node text {
            pointer-events: none;
            font: 10px sans-serif;
        }
    </style>
</head>

<body>
    <script type="text/javascript">
        //Width and height
        var w = 960;
        var h = 600;
        var padding = 5;
        var radius = 50;
        var centerRadius = 60;
        var centerNode = "Ben Athiwaratkun";
         // TODO - Original source should be a json graph
         // Then, derive the dataset for nodes and edges from the nested graph
        var dataset = {
            nodes: [
                {
                    name: "Ben Athiwaratkun"
                },
                {
                    name: "Profile"
                },
                {
                    name: "Kaggle Projects"
                },
                {
                    name: "Ben's Github",
                    link: "https://github.com/benathi"
                },
                {
                    name: "Higgs Boson"
                },
                {
                    name: "Reinforcement Learning"
                },
                {
                    name: "Book Recommendation System"
                },
                {
                    name: "Neural \nNetworks"
                },
                {
                    name: "WebGL"
                },
                {
                    name: "Predicting Malware"
                },
                {
                    name: "Pacman - Q Learning"
                },
                {
                    name: "Technical Toolbox",
                    link: "https://github.com/benathi/MyVimrc"
                },
                {
                    name: "Display Advertising Challenge",
                    link: "https://github.com/benathi/Kaggle-DisplayAdvertisingChallenge"
                }
    ],
            edges: [
                {
                    source: 0,
                    target: 1,
                    direct: 1
                },
                {
                    source: 0,
                    target: 2,
                    direct: 1
                },
                {
                    source: 0,
                    target: 3,
                    direct: 1
                },
                {
                    source: 1,
                    target: 4,
                    direct: 1
                },
                {
                    source: 1,
                    target: 5,
                    direct: 1
                },
                {
                    source: 2,
                    target: 6,
                    direct: 1
                },
                {
                    source: 2,
                    target: 7,
                    direct: 1
                },
                {
                    source: 2,
                    target: 8,
                    direct: 1
                },
                {
                    source: 3,
                    target: 9,
                    direct: 1
                },
                {
                    source: 3,
                    target: 10,
                    direct: 1
                },
                {
                    source: 3,
                    target: 11,
                    direct: 1
                },
                {
                    source: 3,
                    target: 12,
                    direct: 1
                }]
        };

        var force = d3.layout.force()
            .nodes(dataset.nodes) // add nodes to the force layout
            .links(dataset.edges) // add edges to the force layout
            .size([w, h]) // add size of the canvas to the force layout
            .linkDistance(100) // Fix distance
            .charge(-500)
            .linkStrength(0.8) //0.8
            .gravity(0) // 0.25
            // gravity might not be variable
            .start();

        var colors = d3.scale.category20();

         //Create SVG element
        var svg = d3.select("body")
            .append("svg")
            //.attr("viewBox", "0 0 " + w + " " + h)
            //.attr("preserveAspectRatio", "xMidYMid meet")
            .on("mousedown", shake)
            .attr("width", w)
            .attr("height", h);

         // Fading in
        svg.style("opacity", 0)
            .transition()
            .duration(1000)
            .style("opacity", 1);

         //Create edges as lines
        var edges = svg.selectAll("line")
            .data(dataset.edges)
            .enter()
            .append("line")
            .style("stroke", "#eee")
            .style("stroke-width", 1);


        function endall(transition, callback) {
            var n = 0;
            transition
                .each(function () {
                    ++n;
                })
                .each("end", function () {
                    if (!--n) callback.apply(this, arguments);
                });
        }

         // TODO - add backgroud to circle
         // the background should be a vector graphic?
         // need to make sure it scales ok
         // the background will pop up on mousehover as the transparency increased
         // 


         // (2) Nodes
         // 2.1 Each node is a collection g
        var nodes = svg.selectAll(".node")
            .data(dataset.nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .call(force.drag);

         // 2.2 Each node has a circle as an element
        nodes.append("circle")
            .attr("r", function (d) {
                if (d.name == centerNode) {
                    return centerRadius;
                } else {
                    return radius;
                }
            })
            .style("fill", function (d, i) {
                return colors(i);
            })
            .style("fill-opacity", 0.5)
            .on("mouseover", function () {
                d3.select(this)
                    .style("fill-opacity", 0.7);
            })
            .on("mouseout", function () {
                d3.select(this).style("fill-opacity", 0.3)
            })
            .on("click", function (d) {
                var _link_exist = typeof (d.link) != "undefined";
                console.info(_link_exist);
                var _link = d.link

                if (!_link_exist) {
                    // if the link does not exist
                    
                } else {
                    // if the link exists
                    d3.select(this)
                        .transition()
                        .duration(w * 0.6)
                        .attr("r", w * 0.6)
                        .style("fill-opacity", 0.0)
                        .attr("x", w)
                        .remove()
                        .call(endall, function (d) {


                            // want to select all the elements and fade them away
                            svg.selectAll("circle")
                                .transition()
                                .duration(0.4 * w)
                                .delay(function (d, i) {
                                    return i * 20;
                                })
                                .attr("r", 0.4 * w)
                                .style("fill-opacity", 0.0)
                                .remove()
                                .call(endall, function () {
                                    // Load a new page (in a parent frame or current window) when everything is done

                                    top.window.location.href = _link;

                                })
                        });
                }
            })

         // 2.3 Each node has a text label 
         nodes.append("text")
            .attr("text-anchor", "middle")
            .text(function (d) {
                return d.name;
            })
            .style("font-size", 13)
            .attr("fill", function (d, i) {
                return d3.rgb(colors(i)).darker(2);
            })


         // 3. Ticking
         force.on("tick", function () {

            edges.attr("x1", function (d) {
                return d.source.x;
            })
                .attr("y1", function (d) {
                    return d.source.y;
                })
                .attr("x2", function (d) {
                    return d.target.x;
                })
                .attr("y2", function (d) {
                    return d.target.y;
                });

            dataset.nodes.forEach(function (d, i) {
                if (d.name == centerNode) {
                    d.x = w / 2;
                    d.y = w / 4; // TODO - investigate why w/4
                }
            });

            nodes.attr("transform",
                function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

            nodes.each(collide(0.2));


        });




         // TODO - modify this so that it bounces off the walls
        function collide(alpha) {
            var quadtree = d3.geom.quadtree(dataset.nodes);
            return function (d) {
                var rb = 2 * radius + padding,
                    nx1 = d.x - rb,
                    nx2 = d.x + rb,
                    ny1 = d.y - rb,
                    ny2 = d.y + rb;
                quadtree.visit(function (quad, x1, y1, x2, y2) {
                    if (quad.point && (quad.point !== d)) {
                        var x = d.x - quad.point.x,
                            y = d.y - quad.point.y,
                            l = Math.sqrt(x * x + y * y);
                        if (l < rb) {
                            l = (l - rb) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            quad.point.x += x;
                            quad.point.y += y;
                        }
                    }
                    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                });
            };
        }


         // not able to move much due to constraints
         // check if there's something wrong with the method
        function shake() {
            nodes.forEach(function (o, i) {
                o.x += (Math.random() - .5) * 2 * radius;
                o.y += (Math.random() - .5) * 2 * radius;
            });
            force.resume();
        }
    </script>
</body>

</html>